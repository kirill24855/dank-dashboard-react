{"version":3,"sources":["shpLoader.js","components/Globe.jsx","App.js","serviceWorker.js","index.js"],"names":["cache","loadShp","_x","_loadShp","apply","this","arguments","_callee","filePath","response","regenerator_default","a","wrap","_context","prev","next","abrupt","fetch","sent","json","stop","defaultMarkerColor","defaultBorderColor","defaultStickColor","defaultNewStickColor","defaultWarningStickColor","defaultErrorStickColor","defaultEarthGlowColor","Globe","props","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","markerMaterial","THREE","color","markerColor","borderMaterial","borderColor","normalStickMaterial","normalStickColor","newStickMaterial","newStickColor","warningStickMaterial","warningStickColor","errorStickMaterial","errorStickColor","stickWidth","eventDisplayType","xAxis","yAxis","zAxis","origin","focusing","draw","bind","assertThisInitialized","animate","numParallels","numMeridians","earth","equatorGeometry","vertices","shift","equatorMesh","rotation","x","Math","PI","add","i","parallelGeometry","cos","parallelMesh","position","y","sin","meridianMesh","geojson","features","length","country","j","geometry","coordinates","part","Array","k","coords","lat","lng","point","push","line","c","p","uniforms","type","value","glowColor","viewVector","gCamera","vertexShader","fragmentShader","side","blending","transparent","material","stickMesh","pivot","set","rotateObjAroundOrigin","gSticks","toRender","size","mesh","userData","spawnTime","Date","now","sticks","_this2","_loop","stick","fromSource","some","s","addStick","assign","addTime","id","setInterval","spawnCircle","intervalID","_loop2","console","log","clearInterval","index","children","indexOf","splice","rotateAroundWorldAxis","rot","distance","z","lookAt","gScene","glow","width","mount","clientWidth","height","clientHeight","matrixAutoUpdate","fovY","zoom","gRenderer","antialias","setPixelRatio","window","devicePixelRatio","setSize","setClearColor","backgroundColor","mouseRotationSensitivity","ambientRotationRate","isDragging","dragPrev","domElement","addEventListener","e","screenToGlobeCoords","offsetX","offsetY","_this3","mouseCoords","onGlobeClick","document","gFocus","duration","focusDuration","startTime","startLoc","curProgress","load","tex","map","overdraw","rotateY","doubleSided","glowMaterial","getGlowMaterial","earthGlowColor","earthGlow","scale","multiplyScalar","object","loadBorders","addBordersToScene","addMarkersToScene","appendChild","init","prevProps","focusPoint","setState","startLat","startLng","stdDist","abs","addSticks","timestamp","focus","lastRenderTime","rotateCamera","animateSticks","requestAnimationFrame","curTime","progress","d","lifeLength","circle","render","_this4","react_default","createElement","className","ref","r","p1","p2","p3","threshold","x1","y1","x2","y2","x3","y3","x4","y4","axisNorm","radians","second","rotWorldMatrix","makeRotationAxis","multiply","matrix","setFromRotationMatrix","mouseX","mouseY","camera","mouse","raycaster","setFromCamera","intersects","intersectObject","spherePoint","acos","atan2","t","Component","App","randomizeSticks","setupTestEnvironment","style","top","left","onClick","display","Globe_Globe","onChange","handleGlobeChange","b","slice","floor","random","_ref","total","count","shuffle","toConsumableArray","concat","generateSticks","generateStick","Boolean","location","hostname","match","ReactDOM","src_App_0","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"wUAAIA,EAAQ,GAEG,SAAeC,EAA9BC,GAAA,OAAAC,EAAAC,MAAAC,KAAAC,sDAAe,SAAAC,EAAuBC,GAAvB,IAAAC,EAAA,OAAAC,EAAAC,EAAAC,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,WACVf,EAAMQ,GADI,CAAAK,EAAAE,KAAA,eAAAF,EAAAG,OAAA,SACchB,EAAMQ,IADpB,cAAAK,EAAAE,KAAA,EAGOE,MAAMT,GAHb,cAGVC,EAHUI,EAAAK,KAAAL,EAAAE,KAAA,EAIUN,EAASU,OAJnB,cAIdnB,EAAMQ,GAJQK,EAAAK,KAAAL,EAAAG,OAAA,SAMPhB,EAAMQ,IANC,wBAAAK,EAAAO,SAAAb,EAAAF,0CCuBXgB,EAAqB,SACrBC,EAAqB,QAErBC,EAAoBD,EACpBE,EAAuB,QACvBC,EAA2B,SAC3BC,EAAyB,SAEzBC,EAAwBN,EAGPO,cAuDpB,SAAAA,EAAYC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAA1B,KAAAuB,IAClBE,EAAAC,OAAAE,EAAA,EAAAF,CAAA1B,KAAA0B,OAAAG,EAAA,EAAAH,CAAAH,GAAAO,KAAA9B,KAAMwB,KArBPO,MAAQ,CACPC,eAAgB,IAAIC,IAAwB,CAACC,MAAOT,EAAKD,MAAMW,aAAenB,IAC9EoB,eAAgB,IAAIH,IAAwB,CAACC,MAAOT,EAAKD,MAAMa,aAAepB,IAC9EqB,oBAAqB,IAAIL,IAAwB,CAACC,MAAOT,EAAKD,MAAMe,kBAAoBrB,IACxFsB,iBAAkB,IAAIP,IAAwB,CAACC,MAAOT,EAAKD,MAAMiB,eAAiBtB,IAClFuB,qBAAsB,IAAIT,IAAwB,CAACC,MAAOT,EAAKD,MAAMmB,mBAAqBvB,IAC1FwB,mBAAoB,IAAIX,IAAwB,CAACC,MAAOT,EAAKD,MAAMqB,iBAAmBxB,IAEtFyB,WAAYrB,EAAKD,MAAMsB,YAAc,KAErCC,iBAAkBtB,EAAKD,MAAMuB,kBAAoB,SAEjDC,MAAO,IAAIf,IAAc,EAAG,EAAG,GAC/BgB,MAAO,IAAIhB,IAAc,EAAG,EAAG,GAC/BiB,MAAO,IAAIjB,IAAc,EAAG,EAAG,GAC/BkB,OAAQ,IAAIlB,IAAc,EAAG,EAAG,GAEhCmB,UAAU,GAKV3B,EAAK4B,KAAO5B,EAAK4B,KAAKC,KAAV5B,OAAA6B,EAAA,EAAA7B,QAAA6B,EAAA,EAAA7B,CAAAD,KACZA,EAAK+B,QAAU/B,EAAK+B,QAAQF,KAAb5B,OAAA6B,EAAA,EAAA7B,QAAA6B,EAAA,EAAA7B,CAAAD,KAHGA,iFAODgC,EAAcC,EAAcC,GAC7C,IAAIC,EAAkB,IAAI3B,IAAqB,EAAG,KAClD2B,EAAgBC,SAASC,QAGzB,IAAIC,EAAc,IAAI9B,IAAe2B,EAAiB5D,KAAK+B,MAAMC,gBACjE+B,EAAYC,SAASC,EAAIC,KAAKC,GAAG,EACjCR,EAAMS,IAAIL,GAGV,IAAK,IAAIM,EAAI,EAAGA,EAAIH,KAAKC,GAAG,EAAGE,GAAIH,KAAKC,GAAG,GAAGV,EAAa,GAAI,CAC9D,IAAIa,EAAmB,IAAIrC,IAAqBiC,KAAKK,IAAIF,GAAI,KAC7DC,EAAiBT,SAASC,QAC1B,IAAIU,EAAe,IAAIvC,IAAeqC,EAAkBtE,KAAK+B,MAAMC,gBACnEwC,EAAaR,SAASC,EAAIC,KAAKC,GAAG,EAClCK,EAAaC,SAASC,EAAIR,KAAKS,IAAIN,GACnCV,EAAMS,IAAII,IAEVA,EAAe,IAAIvC,IAAeqC,EAAkBtE,KAAK+B,MAAMC,iBAClDgC,SAASC,EAAIC,KAAKC,GAAG,EAClCK,EAAaC,SAASC,GAAKR,KAAKS,IAAIN,GACpCV,EAAMS,IAAII,GAIX,IAAK,IAAIH,EAAI,EAAGA,EAAI,EAAEH,KAAKC,GAAIE,GAAK,EAAEH,KAAKC,GAAGT,EAAc,CAC3D,IAAIkB,EAAe,IAAI3C,IAAe2B,EAAiB5D,KAAK+B,MAAMC,gBAClE4C,EAAaZ,SAASU,EAAIL,EAC1BV,EAAMS,IAAIQ,8CAIMC,EAASlB,GAQ1B,IAAK,IAAIU,EAAI,EAAGA,EAAIQ,EAAQC,SAASC,OAAQV,IAK5C,IAHA,IAAIW,EAAUH,EAAQC,SAAST,GAGtBY,EAAI,EAAGA,EAAID,EAAQE,SAASC,YAAYJ,OAAQE,IAAK,CAC7D,IAAIG,OAAI,EACoDA,EAAxDJ,EAAQE,SAASC,YAAY,GAAG,GAAG,aAAcE,MAAcL,EAAQE,SAASC,YAAYF,GAAG,GACvFD,EAAQE,SAASC,YAAYF,GAKzC,IAJA,IAAIE,EAAc,GAITG,EAAI,EAAGA,EAAIF,EAAKL,OAAQO,IAAK,CAGrC,IAAIC,EAASH,EAAKE,GACdE,EAAMD,EAAO,GAAKrB,KAAKC,GAAK,IAC5BsB,EAAMF,EAAO,GAAKrB,KAAKC,GAAK,IAC5BuB,EAAQ,IAAIzD,IAAciC,KAAKS,IAAIc,GAAOvB,KAAKK,IAAIiB,GAAMtB,KAAKS,IAAIa,GAAMtB,KAAKK,IAAIkB,GAAOvB,KAAKK,IAAIiB,IACrGL,EAAYQ,KAAKD,GAGlB,IAAIR,EAAW,IAAIjD,IACnBiD,EAASrB,SAAWsB,EACpB,IAAIS,EAAO,IAAI3D,IAAWiD,EAAUlF,KAAK+B,MAAMK,gBAC/CuB,EAAMS,IAAIwB,4CAuBGC,EAAGC,EAAG5D,GACrB,OAAO,IAAID,IAAqB,CAC/B8D,SAAU,CACTF,EAAK,CAACG,KAAM,IAAKC,MAAOJ,GACxBC,EAAK,CAACE,KAAM,IAAKC,MAAOH,GACxBI,UAAW,CAACF,KAAM,IAAKC,MAAO,IAAIhE,IAAYC,IAC9CiE,WAAY,CAACH,KAAM,KAAMC,MAAOjG,KAAKoG,QAAQ3B,WAE9C4B,aAAY,oeAcZC,eAAc,mOASdC,KAAMtE,IACNuE,SAAUvE,IACVwE,aAAa,qCAKNjB,EAAKC,EAAKV,EAAQiB,GAC1B,IAAIU,EAAW1G,KAAK+B,MAAMO,oBACb,UAAT0D,IAAkBU,EAAW1G,KAAK+B,MAAMa,oBAE5C,IAAIsC,EAAW,IAAIjD,IAAkBjC,KAAK+B,MAAMe,WAAY9C,KAAK+B,MAAMe,WAAYiC,GAC/E4B,EAAY,IAAI1E,IAAWiD,EAAUwB,GACrCE,EAAQ,IAAI3E,IAQhB,OAPA2E,EAAMxC,IAAIuC,GACVA,EAAUlC,SAASoC,IAAI,EAAG,EAAG,EAAI9B,EAAO,GAExC/E,KAAK8G,sBAAsBF,EAAOpB,EAAKC,GAEvCzF,KAAK+G,QAAQC,SAAS5C,IAAIwC,GAEnBA,sCAGIpB,EAAKC,EAAKwB,EAAMjB,GAC3B,IAAIU,EAAW1G,KAAK+B,MAAMO,oBACb,UAAT0D,IAAkBU,EAAW1G,KAAK+B,MAAMa,oBAE5C,IAAIsC,EAAW,IAAIjD,IAAqBgF,EAAK,GAAI,GAAI,IACjDC,EAAO,IAAIjF,IAAWiD,EAAUwB,GAChCE,EAAQ,IAAI3E,IAChB2E,EAAMxC,IAAI8C,GACVN,EAAMO,SAASD,KAAOA,EACtBA,EAAKzC,SAASoC,IAAI,EAAG,EAAG,GACxBK,EAAKC,SAASC,UAAYC,KAAKC,MAE/BtH,KAAK8G,sBAAsBF,EAAOpB,EAAKC,GAEvCzF,KAAK+G,QAAQC,SAAS5C,IAAIwC,qCAGjBW,GACT,IADiB,IAAAC,EAAAxH,KAAAyH,EAAA,SACRpD,GACR,IAAIqD,EAAQH,EAAOlD,GAEnB,GAAImD,EAAKT,QAAQY,WAAWC,KAAK,SAAAC,GAAC,OAAIA,EAAErC,MAAQkC,EAAMlC,KAAOqC,EAAEpC,MAAQiC,EAAMjC,KAAOoC,EAAEZ,OAASS,EAAMT,MAAQY,EAAE7B,OAAS0B,EAAM1B,OAAO,iBAErI,GAAoC,WAAhCwB,EAAKzF,MAAMgB,iBAA+B,CAC7C,IAAI+C,EAAI0B,EAAKM,SAASJ,EAAMlC,IAAKkC,EAAMjC,IAAKiC,EAAMT,KAAMS,EAAM1B,MAC9DwB,EAAKT,QAAQY,WAAWhC,KAAKjE,OAAOqG,OAAOL,EAAO,CAACV,SAAUlB,EAAGkC,QAASX,KAAKC,cACxE,GAAoC,YAAhCE,EAAKzF,MAAMgB,iBAAgC,CACrD,IAAIkF,EAAKC,YAAY,kBAAMV,EAAKW,YAAYT,EAAMlC,IAAKkC,EAAMjC,IAAKiC,EAAMT,KAAMS,EAAM1B,OAAO,KAC3FwB,EAAKT,QAAQY,WAAWhC,KAAKjE,OAAOqG,OAAOL,EAAO,CAACU,WAAYH,EAAID,QAASX,KAAKC,WAV1EjD,EAAI,EAAGA,EAAIkD,EAAOxC,OAAQV,IAAKoD,EAA/BpD,GADQ,IAAAgE,EAAA,SAeRhE,GACR,IAAIqD,EAAQF,EAAKT,QAAQY,WAAWtD,GAEpC,GAAIkD,EAAOK,KAAK,SAAAC,GAAC,OAAIA,EAAErC,MAAQkC,EAAMlC,KAAOqC,EAAEpC,MAAQiC,EAAMjC,KAAOoC,EAAEZ,OAASS,EAAMT,MAAQY,EAAE7B,OAAS0B,EAAM1B,OAAO,iBAEpH,GAAoC,YAAhCwB,EAAKzF,MAAMgB,iBACduF,QAAQC,IAAIb,EAAMU,YAClBI,cAAcd,EAAMU,iBACd,GAAoC,WAAhCZ,EAAKzF,MAAMgB,iBAA+B,CACpD,IAAI0F,EAAQjB,EAAKT,QAAQC,SAAS0B,SAASC,QAAQjB,EAAMV,UACzDQ,EAAKT,QAAQC,SAAS0B,SAASE,OAAOH,EAAO,GAE9CjB,EAAKT,QAAQY,WAAWiB,OAAOvE,EAAG,IAZnC,IAASA,EAAIkD,EAAOxC,OAAO,EAAGV,GAAK,EAAGA,IAAKgE,EAAlChE,iDAgBYuC,EAAOpB,EAAKC,GACjClE,EAAMsH,sBAAsBjC,EAAO5G,KAAK+B,MAAMiB,OAAQwC,EAAMtB,KAAKC,GAAK,KAAK,GAC3E5C,EAAMsH,sBAAsBjC,EAAO5G,KAAK+B,MAAMkB,MAAQwC,EAAMvB,KAAKC,GAAK,KAAK,0CAY3E,IAAIsB,EAAMzF,KAAKoG,QAAQ0C,IAAIrD,IAAMvB,KAAKC,GAAK,IACvCqB,EAAMxF,KAAKoG,QAAQ0C,IAAItD,IAAMtB,KAAKC,GAAK,IAE3CnE,KAAKoG,QAAQ3B,SAASR,EAAIC,KAAKS,IAAIc,GAAOvB,KAAKK,IAAIiB,GAAOxF,KAAKoG,QAAQ2C,SACvE/I,KAAKoG,QAAQ3B,SAASC,EAAIR,KAAKS,IAAIa,GAAOxF,KAAKoG,QAAQ2C,SACvD/I,KAAKoG,QAAQ3B,SAASuE,EAAI9E,KAAKK,IAAIkB,GAAOvB,KAAKK,IAAIiB,GAAOxF,KAAKoG,QAAQ2C,SACvE/I,KAAKoG,QAAQ6C,OAAOjJ,KAAK+B,MAAMoB,QAK/BnD,KAAKkJ,OAAO/B,SAASxD,MAAMwD,SAASgC,KAAKzC,SAASX,SAASI,WAAWF,MAAQjG,KAAKoG,QAAQ3B,wKAwBvF2E,EAAQpJ,KAAKqJ,MAAMC,YACnBC,EAASvJ,KAAKqJ,MAAMG,aAExBxJ,KAAKkJ,OAAS,IAAIjH,IAClBjC,KAAKkJ,OAAOO,kBAAmB,EAC/BzJ,KAAKoG,QAAU,IAAInE,IAAwBjC,KAAKwB,MAAMkI,MAAQ,GAAIN,EAAMG,EAAQ,GAAK,IAErFvJ,KAAKoG,QAAQ2C,SAAW/I,KAAKwB,MAAMmI,KAAO,GAAK,EAC/C3J,KAAKoG,QAAQ3B,SAASuE,EAAIhJ,KAAKoG,QAAQ2C,SACvC/I,KAAKoG,QAAQ0C,IAAM,CAACrD,IAAK,EAAGD,IAAK,GACjCxF,KAAKoG,QAAQe,SAASP,MAAQ,IAAI3E,IAClCjC,KAAKoG,QAAQe,SAASP,MAAMxC,IAAIpE,KAAKoG,SACrCpG,KAAKkJ,OAAO9E,IAAIpE,KAAKoG,QAAQe,SAASP,OAEtC5G,KAAK4J,UAAY,IAAI3H,IAAoB,CAAC4H,WAAW,IACrD7J,KAAK4J,UAAUE,cAAcC,OAAOC,kBACpChK,KAAK4J,UAAUK,QAAQb,EAAOG,GAC9BvJ,KAAK4J,UAAUM,cAAclK,KAAKwB,MAAM2I,iBAAmB,EAAU,GAErEnK,KAAKoK,yBAA2BpK,KAAKwB,MAAM4I,0BAA4B,GACvEpK,KAAKqK,oBAAsBrK,KAAKwB,MAAM6I,qBAAuB,EAG7DrK,KAAKsK,YAAa,EAClBtK,KAAKuK,SAAW,CAACtG,EAAG,EAAGS,EAAG,GAE1B1E,KAAK4J,UAAUY,WAAWC,iBAAiB,QAAS,SAAAC,GACnD,IAAInF,EAAShE,EAAMoJ,oBAAoBD,EAAEE,QAAQxB,GAAQG,EAAOmB,EAAEG,SAAStB,EAAQuB,EAAK1E,QAAS0E,EAAK5B,OAAO/B,SAASxD,OACxG,MAAV4B,GACAuF,EAAKC,YAAY9G,IAAMyG,EAAEE,SAAWE,EAAKC,YAAYrG,IAAMgG,EAAEG,SACjEC,EAAKtJ,MAAMwJ,aAAazF,KAEzBvF,KAAK4J,UAAUY,WAAWC,iBAAiB,YAAa,SAAAC,GACvDI,EAAKR,YAAa,EAClBQ,EAAKC,YAAc,CAAC9G,EAAGyG,EAAEE,QAASlG,EAAGgG,EAAEG,WAExC7K,KAAK4J,UAAUY,WAAWC,iBAAiB,YAAa,SAAAC,GACnDI,EAAKR,aACRQ,EAAK1E,QAAQ0C,IAAIrD,MAAQiF,EAAEE,QAAQE,EAAKP,SAAStG,GAAG6G,EAAKV,yBACzDU,EAAK1E,QAAQ0C,IAAItD,MAAQkF,EAAEG,QAAQC,EAAKP,SAAS7F,GAAGoG,EAAKV,yBAErDU,EAAK1E,QAAQ0C,IAAItD,IAAM,KAAIsF,EAAK1E,QAAQ0C,IAAItD,IAAM,IAClDsF,EAAK1E,QAAQ0C,IAAItD,KAAO,KAAIsF,EAAK1E,QAAQ0C,IAAItD,KAAO,IACpDsF,EAAK1E,QAAQ0C,IAAIrD,IAAM,MAAKqF,EAAK1E,QAAQ0C,IAAIrD,KAAO,KACpDqF,EAAK1E,QAAQ0C,IAAIrD,KAAO,MAAKqF,EAAK1E,QAAQ0C,IAAIrD,KAAO,MAM1DqF,EAAKP,SAAW,CAACtG,EAAGyG,EAAEE,QAASlG,EAAGgG,EAAEG,WAIrCI,SAASR,iBAAiB,UAAW,kBAAMK,EAAKR,YAAa,IAE7DtK,KAAK+G,QAAU,GACf/G,KAAK+G,QAAQC,SAAW,IAAI/E,IAC5BjC,KAAKkJ,OAAO9E,IAAIpE,KAAK+G,QAAQC,UAC7BhH,KAAK+G,QAAQY,WAAa,GAE1B3H,KAAKkJ,OAAO9E,IAAI,IAAInC,IAAmB,SAAU,IAEjDjC,KAAKkL,OAAS,CACbC,SAAUnL,KAAKwB,MAAM4J,eAAiB,IACtCC,UAAW,EACXC,SAAU,CACT9F,IAAK,EACLC,IAAK,GAEN8F,YAAa,GAIV5H,EAAQ,IAAI1B,IAChBjC,KAAKkJ,OAAO9E,IAAIT,IAChB,IAAI1B,KAAsBuJ,KAAK,4BAA6B,SAAAC,GAC3D,IAAIvG,EAAW,IAAIjD,IAAqB,KAAO,IAAK,KAChDyE,EAAW,IAAIzE,IAAwB,CAACyJ,IAAKD,EAAKE,SAAU,KAC5DzE,EAAO,IAAIjF,IAAWiD,EAAUwB,GACpCQ,EAAK0E,QAAQ,EAAE1H,KAAKC,GAAG,GACvB+C,EAAK2E,aAAc,EACnBlI,EAAMS,IAAI8C,GAGV,IAAI4E,EAAehB,EAAKiB,gBAAgB,GAAK,EAAGjB,EAAKtJ,MAAMwK,gBAAkB1K,GACzE2K,EAAY,IAAIhK,IAAWiD,EAAU4G,GACzCG,EAAUC,MAAMC,eAAe,MAC/BxI,EAAMS,IAAI6H,GAEVtI,EAAMwD,SAASiF,OAASlF,EACxBvD,EAAMwD,SAASgC,KAAO8C,SAMvBjM,eAA6BqM,EAAY,+DAAgC1I,OAApE2I,4CACLtM,eAA6BqM,EAAY,8DAAsC1I,OAA1E2I,uCAELtM,KAAKuM,kBAAkB,EAAG,GAAI5I,GAE9B3D,KAAKkJ,OAAO/B,SAASxD,MAAQA,EAE7BoG,OAAO7B,YAAY,kBAAMI,QAAQC,IAAIuC,EAAK/D,QAAQC,SAAS0B,SAAS3D,SAAS,KAE7E/E,KAAKqJ,MAAMmD,YAAYxM,KAAK4J,UAAUY,mRAIhCxK,KAAKyM,cACXzM,KAAKwD,uJASakJ,GAClB,GAAI1M,KAAKwB,MAAMmL,aAAeD,EAAUC,YAAuC,MAAzB3M,KAAKwB,MAAMmL,WAAoB,CACpF3M,KAAK4M,SAAS,CAACxJ,UAAU,IACzBpD,KAAKkL,OAAOG,UAAYhE,KAAKC,MAE7B,IAAIuF,EAAW7M,KAAKoG,QAAQ0C,IAAItD,IAC5BsH,EAAW9M,KAAKoG,QAAQ0C,IAAIrD,IAC5BsH,EAAU/M,KAAKwB,MAAMmL,WAAWlH,IAAMqH,EAGtC5I,KAAK8I,IAAID,GAAW,MAAKD,GAAY,KACzCC,EAAU/M,KAAKwB,MAAMmL,WAAWlH,IAAMqH,EAClC5I,KAAK8I,IAAID,GAAW,MAAKD,GAAY,KAEzC9M,KAAKkL,OAAOI,SAAW,CAAC9F,IAAKqH,EAAUpH,IAAKqH,GAIzC9M,KAAKwB,MAAM+F,SAAWmF,EAAUnF,QACnCvH,KAAKiN,UAAUjN,KAAKwB,MAAM+F,wCAIpB2F,GACFA,GAKDlN,KAAK+B,MAAMqB,SAAUpD,KAAKmN,SAExBnN,KAAKoG,QAAQe,SAASiG,iBAAgBpN,KAAKoG,QAAQe,SAASiG,eAAiBF,GAClFlN,KAAKoG,QAAQ0C,IAAIrD,KAAOzF,KAAKqK,qBAAqB6C,EAAYlN,KAAKoG,QAAQe,SAASiG,gBAAgB,IAChGpN,KAAKoG,QAAQ0C,IAAIrD,IAAM,MAAKzF,KAAKoG,QAAQ0C,IAAIrD,KAAO,KACxDzF,KAAKqN,gBAGNrN,KAAKsN,gBAELtN,KAAKqD,OACLrD,KAAKoG,QAAQe,SAASiG,eAAiBF,EACvCK,sBAAsBvN,KAAKwD,UAhB1B+J,sBAAsBvN,KAAKwD,yCAoB5B,IAAIgK,EAAUnG,KAAKC,MACnBtH,KAAKkL,OAAOK,YAAciC,EAAUxN,KAAKkL,OAAOG,UAC5CrL,KAAKkL,OAAOK,YAAcvL,KAAKkL,OAAOC,WACzCnL,KAAK4M,SAAS,CAACxJ,UAAU,IACzBpD,KAAKkL,OAAOK,YAAcvL,KAAKkL,OAAOC,UAGvC,IAAIsC,EAAWzN,KAAKkL,OAAOK,YAAcvL,KAAKkL,OAAOC,SACrDnL,KAAKoG,QAAQ0C,IAAItD,KAAOxF,KAAKwB,MAAMmL,WAAWnH,IAAMxF,KAAKkL,OAAOI,SAAS9F,KAAOjE,EAAMmM,EAAED,GAAYzN,KAAKkL,OAAOI,SAAS9F,IACzHxF,KAAKoG,QAAQ0C,IAAIrD,KAAOzF,KAAKwB,MAAMmL,WAAWlH,IAAMzF,KAAKkL,OAAOI,SAAS7F,KAAOlE,EAAMmM,EAAED,GAAYzN,KAAKkL,OAAOI,SAAS7F,IAEzHzF,KAAKqN,uDAML,IAAIG,EAAUnG,KAAKC,MAEnB,GAAoC,WAAhCtH,KAAK+B,MAAMgB,iBACd,IAAK,IAAIsB,KAAKrE,KAAK+G,QAAQY,WAAY,CACtC,IAAID,EAAQ1H,KAAK+G,QAAQY,WAAWtD,GAEhCsJ,EAAaH,EAAU9F,EAAMM,QAC7B2F,EAAa,MAEjBjG,EAAMV,SAAS0B,SAAS,GAAGjE,SAASuE,EAAI,EAAItB,EAAMT,MAAQ1F,EAAMmM,EAAEC,EAAW,KAAM,UAE9E,GAAoC,YAAhC3N,KAAK+B,MAAMgB,iBACrB,IAAK,IAAIsB,EAAIrE,KAAK+G,QAAQC,SAAS0B,SAAS3D,OAAO,EAAGV,GAAK,EAAGA,IAAK,CAClE,IAAIuJ,EAAS5N,KAAK+G,QAAQC,SAAS0B,SAASrE,GAAG8C,SAASD,KAEpDyG,EAAaH,EAAUI,EAAOzG,SAASC,UACvCuG,EAAa,IAAM3N,KAAK+G,QAAQC,SAAS0B,SAASE,OAAOvE,EAAG,GAC3DuJ,EAAOnJ,SAASuE,EAAI,EAA6B,GAAzBzH,EAAMmM,EAAEC,EAAW,qCASlD3N,KAAK4J,UAAUiE,OAAO7N,KAAKkJ,OAAQlJ,KAAKoG,0CAGhC,IAAA0H,EAAA9N,KACR,OACC+N,EAAAzN,EAAA0N,cAAA,OAAKC,UAAU,gBACdC,IAAK,SAACC,GAAD,OAAOL,EAAKzE,MAAQ8E,+CA5XLC,EAAIC,EAAIC,EAAIC,GAClC,IAAIC,EAAKJ,EAAG,GACRK,EAAKL,EAAG,GACRM,EAAKL,EAAG,GACRM,EAAKN,EAAG,GACRO,EAAKN,EAAG,GACRO,EAAKP,EAAG,GACRQ,GAAMJ,GAAIF,EAAGI,IAAKC,EAAGJ,GAAMD,GAAIK,EAAGJ,IAAKG,EAAGJ,GAAMC,EAAKE,KAAQH,EAAGI,IAAKC,EAAGJ,IAAOI,EAAGJ,IAAKG,EAAGJ,IAC1FO,GAAMF,EAAGJ,IAAKG,EAAGJ,IAAOM,EAAGN,GAAMC,EAGrC,OAFgBK,EAAGJ,IAAKI,EAAGJ,IAAOK,EAAGJ,IAAKI,EAAGJ,GAEdJ,gDA+GHnC,EAAQ4C,EAAUC,EAASC,GACvD,IAAIC,EAAiB,IAAIlN,IACzBkN,EAAeC,iBAAiBJ,EAAUC,GACtCC,GAAQC,EAAeE,SAASjD,EAAOkD,QAC3ClD,EAAOkD,OAASH,EAChB/C,EAAOpI,SAASuL,sBAAsBnD,EAAOkD,oDAkBnBE,EAAQC,EAAQC,EAAQ/L,GAClD,IAAIgM,EAAQ,IAAI1N,IAChB0N,EAAM1L,EAAW,EAAPuL,EAAS,EACnBG,EAAMjL,EAAW,EAAP+K,EAAS,EAEnB,IAAIG,EAAY,IAAI3N,IACpB2N,EAAUC,cAAcF,EAAOD,GAC/B,IAAII,EAAaF,EAAUG,gBAAgBpM,GAC3C,GAAkB,MAAdmM,GAA4C,IAAtBA,EAAW/K,OAArC,CAEA,IAAIiL,EAAc,IAAI/N,IAOtB,OANA+N,EAAY/L,EAAI6L,EAAW,GAAGpK,MAAMzB,EACpC+L,EAAYtL,EAAIoL,EAAW,GAAGpK,MAAMhB,EACpCsL,EAAYhH,EAAI8G,EAAW,GAAGpK,MAAMsD,EAI7B,CAACxD,IAFE,GAAgC,IAA3BtB,KAAK+L,KAAKD,EAAYtL,GAAWR,KAAKC,GAEnCsB,KADN,IAAiD,IAA3CvB,KAAKgM,MAAMF,EAAY/L,EAAG+L,EAAYhH,GAAW9E,KAAKC,IAAM,IAAO,gCAkN7EgM,GAAI,OAAQ,EAAEA,EAAEA,GAAGA,EAAE,YA5fIC,aCoDpBC,6MAlFdtO,MAAQ,CACPwF,OAAQ,GACRoF,WAAY,+HAKApH,mDA4CU,IAAAiC,EAAAxH,KACtBkI,YAAY,WACX,IAAIX,EAAS8I,EAAIC,gBAAgB9I,EAAKzF,MAAMwF,OAAQ,IAAK,IACzDC,EAAKoF,SAAS,CAACrF,YACb,iDAIHvH,KAAKuQ,wDAGG,IAAAzF,EAAA9K,KACR,OACC+N,EAAAzN,EAAA0N,cAAA,OAAKwC,MAAO,CAACpH,MAAM,OAAQG,OAAO,OAAQ9E,SAAS,WAAYgM,IAAI,IAAKC,KAAK,MAE5E3C,EAAAzN,EAAA0N,cAAA,UAAQ2C,QAAS,WAAK7F,EAAK8B,SAAS,CAACD,WAAY,CAACnH,IAAK,KAAMC,IAAK,UAAlE,SACAsI,EAAAzN,EAAA0N,cAAA,OAAKwC,MAAO,CAACpH,MAAM,OAAQG,OAAO,OAAQqH,QAAQ,iBACjD7C,EAAAzN,EAAA0N,cAAC6C,EAAD,CACClE,WAAY3M,KAAK+B,MAAM4K,WACvBpF,OAAQvH,KAAK+B,MAAMwF,OACnBzE,WAAY,KACZC,iBAAkB,UAClB+N,SAAU9Q,KAAK+Q,kBAAkBzN,KAAKtD,MACtCgL,aAAchL,KAAKgL,aAAa1H,KAAKtD,4CAzD3BgR,GAEd,IADA,IAAI1Q,EAAI0Q,EAAEC,MAAM,GACP5M,EAAI/D,EAAEyE,OAAO,EAAGV,EAAI,EAAGA,IAAK,CACpC,IAAMY,EAAIf,KAAKgN,MAAMhN,KAAKiN,UAAY9M,EAAE,IACxC,GAAIA,IAAMY,EAAV,CAFoC,IAAAmM,EAGrB,CAAC9Q,EAAE2E,GAAI3E,EAAE+D,IAAvB/D,EAAE+D,GAHiC+M,EAAA,GAG7B9Q,EAAE2E,GAH2BmM,EAAA,IAKrC,OAAO9Q,0CAGeiH,EAAQ8J,EAAOC,GAIrC,OAHA/J,EAAS8I,EAAIkB,QAAQhK,GAAQ0J,MAAM,EAAGK,GACtC/J,EAAM7F,OAAA8P,EAAA,EAAA9P,CAAO6F,GAAPkK,OAAA/P,OAAA8P,EAAA,EAAA9P,CAAkB2O,EAAIqB,eAAeL,EAAMC,6CAMjD,MAAO,CACNtL,KAAM9B,KAAKiN,SAAW,GAAM,QAAU,SACtClK,KAAsB,GAAhB/C,KAAKiN,SACX3L,IAAqB,IAAhBtB,KAAKiN,SAAiB,GAC3B1L,IAAqB,IAAhBvB,KAAKiN,SAAiB,4CAIPG,GAErB,IADA,IAAM/J,EAAS,GACNlD,EAAI,EAAGA,EAAIiN,EAAOjN,IAC1BkD,EAAO5B,KAAK0K,EAAIsB,iBAEjB,OAAOpK,SAlDS6I,aCMEwB,QACW,cAA7B7H,OAAO8H,SAASC,UAEe,UAA7B/H,OAAO8H,SAASC,UAEhB/H,OAAO8H,SAASC,SAASC,MACvB,2DCVNC,IAASnE,OAAOE,EAAAzN,EAAA0N,cAACiE,EAAD,MAAShH,SAASiH,eAAe,SDmH3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.06bf117b.chunk.js","sourcesContent":["let cache = {};\n\nexport default async function loadShp(filePath) {\n\tif (cache[filePath]) return cache[filePath];\n\n\tlet response = await fetch(filePath);\n\tcache[filePath] = await response.json();\n\n\treturn cache[filePath];\n}\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport * as THREE from \"three\";\nimport loadBorders from \"../shpLoader\";\nimport \"./Globe.css\";\n\n/*\n * Done with globe and country borders\n * TODO Now, looking for a higher-res globe texture, maybe\n * Also need to get data for all states of the US, and maybe other large countries like Russia, Canada, etc\n * Gotta configure some type of networking and listening for data from a server, so as to update the sticks in real time\n * \t\tactually no, bad idea. the super component should do that, and just give the globe what it needs. eNcApSuLaTiOn\n * TODO Add labels to countries and sticks?\n * TODO Make sticks' length represent a number (people or some such)\n * \t\talready kinda happening, the size/length is decided by the super so its up to that component\n * Change appearance of sticks to signify important notifications (errors, closed deals, etc)\n * TODO Border glow? maybe sticks too\n * Stick animations - go away from traditional actual sticks and instead to like circles emanating from the globe\n * \t\tTODO Now make it actually look good - transparency, smoothness, maybe a haze?\n *\n * Write functionality for the FOCUS POINT, to rotate the globe to given coordinates in response to an event (errors, closed deals, etc)\n *\n * Return the (lat, lng) of a click to the parent, maybe along with the country name\n */\n\nlet defaultMarkerColor = 0x9ff9ff;\nlet defaultBorderColor = 0x4cc4ff;\n\nlet defaultStickColor = defaultBorderColor;\nlet defaultNewStickColor = 0x51e85b;\nlet defaultWarningStickColor = 0xffe759;\nlet defaultErrorStickColor = 0xff6e59;\n\nlet defaultEarthGlowColor = defaultMarkerColor;\n//let defaultBorderGlowColor = defaultWarningStickColor;\n\nexport default class Globe extends Component {\n\n\tstatic propTypes = {\n\t\tbackgroundColor: PropTypes.number,\n\t\tborderColor: PropTypes.number,\n\t\tmarkerColor: PropTypes.number,\n\t\t//countryFillColor: PropTypes.string,\n\n\t\tearthGlowColor: PropTypes.number,\n\t\tborderGlowColor: PropTypes.number,\n\n\t\tfovY: PropTypes.number,\n\t\tzoom: PropTypes.number,\n\t\tmouseRotationSensitivity: PropTypes.number,\n\t\tambientRotationRate: PropTypes.number,\n\n\t\tsticks: PropTypes.array,\n\t\tstickWidth: PropTypes.number,\n\n\t\tnormalStickColor: PropTypes.number,\n\t\tnewStickColor: PropTypes.number,\n\t\twarningStickColor: PropTypes.number,\n\t\terrorStickColor: PropTypes.number,\n\n\t\teventDisplayType: PropTypes.string,\n\n\t\tfocusPoint: PropTypes.object,\n\t\tfocusDuration: PropTypes.number,\n\n\t\tnewStickAnimationDuration: PropTypes.number,\n\n\t\tonChange: PropTypes.func.isRequired,\n\t\tonGlobeClick: PropTypes.func.isRequired,\n\t};\n\n\tstate = {\n\t\tmarkerMaterial: new THREE.LineBasicMaterial({color: this.props.markerColor || defaultMarkerColor}),\n\t\tborderMaterial: new THREE.LineBasicMaterial({color: this.props.borderColor || defaultBorderColor}),\n\t\tnormalStickMaterial: new THREE.MeshPhongMaterial({color: this.props.normalStickColor || defaultStickColor}),\n\t\tnewStickMaterial: new THREE.MeshPhongMaterial({color: this.props.newStickColor || defaultNewStickColor}),\n\t\twarningStickMaterial: new THREE.MeshPhongMaterial({color: this.props.warningStickColor || defaultWarningStickColor}),\n\t\terrorStickMaterial: new THREE.MeshPhongMaterial({color: this.props.errorStickColor || defaultErrorStickColor}),\n\n\t\tstickWidth: this.props.stickWidth || 0.005,\n\n\t\teventDisplayType: this.props.eventDisplayType || \"sticks\",\n\n\t\txAxis: new THREE.Vector3(1, 0, 0),\n\t\tyAxis: new THREE.Vector3(0, 1, 0),\n\t\tzAxis: new THREE.Vector3(0, 0, 1),\n\t\torigin: new THREE.Vector3(0, 0, 0),\n\n\t\tfocusing: false,\n\t};\n\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.draw = this.draw.bind(this);\n\t\tthis.animate = this.animate.bind(this);\n\t}\n\n\t// equator, parallels, and meridians\n\taddMarkersToScene(numParallels, numMeridians, earth) {\n\t\tlet equatorGeometry = new THREE.CircleGeometry(1, 360);\n\t\tequatorGeometry.vertices.shift();\n\n\t\t// equator\n\t\tlet equatorMesh = new THREE.LineLoop(equatorGeometry, this.state.markerMaterial);\n\t\tequatorMesh.rotation.x = Math.PI/2;\n\t\tearth.add(equatorMesh);\n\n\t\t// parallels\n\t\tfor (let i = 0; i < Math.PI/2; i+= Math.PI/2/(numParallels+1)) {\n\t\t\tlet parallelGeometry = new THREE.CircleGeometry(Math.cos(i), 360);\n\t\t\tparallelGeometry.vertices.shift();\n\t\t\tlet parallelMesh = new THREE.LineLoop(parallelGeometry, this.state.markerMaterial);\n\t\t\tparallelMesh.rotation.x = Math.PI/2;\n\t\t\tparallelMesh.position.y = Math.sin(i);\n\t\t\tearth.add(parallelMesh);\n\n\t\t\tparallelMesh = new THREE.LineLoop(parallelGeometry, this.state.markerMaterial);\n\t\t\tparallelMesh.rotation.x = Math.PI/2;\n\t\t\tparallelMesh.position.y = -Math.sin(i);\n\t\t\tearth.add(parallelMesh);\n\t\t}\n\n\t\t// meridians\n\t\tfor (let i = 0; i < 2*Math.PI; i += 2*Math.PI/numMeridians) {\n\t\t\tlet meridianMesh = new THREE.LineLoop(equatorGeometry, this.state.markerMaterial);\n\t\t\tmeridianMesh.rotation.y = i;\n\t\t\tearth.add(meridianMesh);\n\t\t}\n\t}\n\n\taddBordersToScene(geojson, earth) {\n\t\t// use to find buggy countries\n\t\t//geojson.features = geojson.features.filter(rec => rec.properties.NAME === \"Greenland\");\n\t\t//debugger;\n\n\t\t//let glowMaterial = this.getGlowMaterial(0.4, 6, this.props.borderGlowColor || defaultBorderGlowColor);\n\n\t\t// every country\n\t\tfor (let i = 0; i < geojson.features.length; i++) {\n\t\t\t//let i = 144;\n\t\t\tlet country = geojson.features[i];\n\n\t\t\t// every unconnected part of the country\n\t\t\tfor (let j = 0; j < country.geometry.coordinates.length; j++) {\n\t\t\t\tlet part;\n\t\t\t\tif (country.geometry.coordinates[0][0][0] instanceof Array) part = country.geometry.coordinates[j][0];\n\t\t\t\telse part = country.geometry.coordinates[j];\n\t\t\t\tlet coordinates = [];\n\n\t\t\t\t// every point of the border of the part\n\t\t\t\t// change the increment in k to skip points when creating borders - improves performance, but hurts straight-line borders like Egypt, Alaska, etc\n\t\t\t\tfor (let k = 0; k < part.length; k++) {\n\t\t\t\t\t//if ((k !== 0 && k !== part.length-1) && (Globe.skipSecondPoint(part[k-1], part[k], part[k+1], 0.00005))) continue; // 0.00001\n\n\t\t\t\t\tlet coords = part[k];\n\t\t\t\t\tlet lat = coords[1] * Math.PI / 180;\n\t\t\t\t\tlet lng = coords[0] * Math.PI / 180;\n\t\t\t\t\tlet point = new THREE.Vector3(Math.sin(lng) * Math.cos(lat), Math.sin(lat), Math.cos(lng) * Math.cos(lat));\n\t\t\t\t\tcoordinates.push(point);\n\t\t\t\t}\n\n\t\t\t\tlet geometry = new THREE.Geometry();\n\t\t\t\tgeometry.vertices = coordinates;\n\t\t\t\tlet line = new THREE.Line(geometry, this.state.borderMaterial);\n\t\t\t\tearth.add(line);\n\n\t\t\t\t//let glow = new THREE.Line(geometry, glowMaterial);\n\t\t\t\t//glow.scale.multiplyScalar(1.01);\n\t\t\t\t//earth.add(glow);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic skipSecondPoint(p1, p2, p3, threshold) {\n\t\tlet x1 = p1[0];\n\t\tlet y1 = p1[1];\n\t\tlet x2 = p2[0];\n\t\tlet y2 = p2[1];\n\t\tlet x3 = p3[0];\n\t\tlet y3 = p3[1];\n\t\tlet x4 = (x2*(x1-x3)/(y3-y1) - x1*(y3-y1)/(x3-x1) + y1 - y2) / ((x1-x3)/(y3-y1) - (y3-y1)/(x3-x1));\n\t\tlet y4 = (y3-y1)/(x3-x1) * (x4-x1) + y1;\n\t\tlet hSquared = (x4-x2)*(x4-x2) + (y4-y2)*(y4-y2);\n\t\t//let bSquared = (x3-x1)*(x3-x1) + (y3-y1)*(y3-y1);\n\t\treturn hSquared/*/bSquared*/ < threshold;\n\t}\n\n\tgetGlowMaterial(c, p, color) {\n\t\treturn new THREE.ShaderMaterial({\n\t\t\tuniforms: {\n\t\t\t\t\"c\": {type: \"f\", value: c},\n\t\t\t\t\"p\": {type: \"f\", value: p},\n\t\t\t\tglowColor: {type: \"c\", value: new THREE.Color(color)},\n\t\t\t\tviewVector: {type: \"v3\", value: this.gCamera.position}\n\t\t\t},\n\t\t\tvertexShader: `\n\t\t\t\t\tuniform vec3 viewVector;\n\t\t\t\t\tuniform float c;\n\t\t\t\t\tuniform float p;\n\t\t\t\t\tvarying float intensity;\n\t\t\t\t\tvoid main() \n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 vNormal = normalize( normalMatrix * normal );\n\t\t\t\t\t\tvec3 vNormel = normalize( normalMatrix * viewVector );\n\t\t\t\t\t\tintensity = pow( c - dot(vNormal, vNormel), p );\n\t\t\t\t\t\t\n\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\t}\n\t\t\t`,\n\t\t\tfragmentShader: `\n\t\t\t\t\tuniform vec3 glowColor;\n\t\t\t\t\tvarying float intensity;\n\t\t\t\t\tvoid main() \n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 glow = glowColor * intensity;\n\t\t\t\t\t\tgl_FragColor = vec4( glow, 1.0 );\n\t\t\t\t\t}\n\t\t\t`,\n\t\t\tside: THREE.BackSide,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\ttransparent: true,\n\t\t});\n\t}\n\n\t// OLD - creates an actual stick, use spawnCircle instead to form imaginary sticks\n\taddStick(lat, lng, length, type) {\n\t\tlet material = this.state.normalStickMaterial;\n\t\tif (type === \"error\") material = this.state.errorStickMaterial;\n\n\t\tlet geometry = new THREE.BoxGeometry(this.state.stickWidth, this.state.stickWidth, length);\n\t\tlet stickMesh = new THREE.Mesh(geometry, material);\n\t\tlet pivot = new THREE.Object3D();\n\t\tpivot.add(stickMesh);\n\t\tstickMesh.position.set(0, 0, 1 - length/2);\n\n\t\tthis.rotateObjAroundOrigin(pivot, lat, lng);\n\n\t\tthis.gSticks.toRender.add(pivot);\n\n\t\treturn pivot;\n\t}\n\n\tspawnCircle(lat, lng, size, type) {\n\t\tlet material = this.state.normalStickMaterial;\n\t\tif (type === \"error\") material = this.state.errorStickMaterial;\n\n\t\tlet geometry = new THREE.SphereGeometry(size/10, 10, 10);\n\t\tlet mesh = new THREE.Mesh(geometry, material);\n\t\tlet pivot = new THREE.Object3D();\n\t\tpivot.add(mesh);\n\t\tpivot.userData.mesh = mesh;\n\t\tmesh.position.set(0, 0, 1);\n\t\tmesh.userData.spawnTime = Date.now();\n\n\t\tthis.rotateObjAroundOrigin(pivot, lat, lng);\n\n\t\tthis.gSticks.toRender.add(pivot);\n\t}\n\n\taddSticks(sticks) {\n\t\tfor (let i = 0; i < sticks.length; i++) { // add new sticks\n\t\t\tlet stick = sticks[i];\n\n\t\t\tif (this.gSticks.fromSource.some(s => s.lat === stick.lat && s.lng === stick.lng && s.size === stick.size && s.type === stick.type)) continue;\n\n\t\t\tif (this.state.eventDisplayType === \"sticks\") {\n\t\t\t\tlet p = this.addStick(stick.lat, stick.lng, stick.size, stick.type);\n\t\t\t\tthis.gSticks.fromSource.push(Object.assign(stick, {toRender: p, addTime: Date.now()}));\n\t\t\t} else if (this.state.eventDisplayType === \"circles\") {\n\t\t\t\tlet id = setInterval(() => this.spawnCircle(stick.lat, stick.lng, stick.size, stick.type), 100);\n\t\t\t\tthis.gSticks.fromSource.push(Object.assign(stick, {intervalID: id, addTime: Date.now()}));\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = sticks.length-1; i >= 0; i--) { // remove old sticks\n\t\t\tlet stick = this.gSticks.fromSource[i];\n\n\t\t\tif (sticks.some(s => s.lat === stick.lat && s.lng === stick.lng && s.size === stick.size && s.type === stick.type)) continue;\n\n\t\t\tif (this.state.eventDisplayType === \"circles\") {\n\t\t\t\tconsole.log(stick.intervalID);\n\t\t\t\tclearInterval(stick.intervalID); // TODO figure out why the fuck intervalID isnt purple\n\t\t\t} else if (this.state.eventDisplayType === \"sticks\") {\n\t\t\t\tlet index = this.gSticks.toRender.children.indexOf(stick.toRender);\n\t\t\t\tthis.gSticks.toRender.children.splice(index, 1);\n\t\t\t}\n\t\t\tthis.gSticks.fromSource.splice(i, 1);\n\t\t}\n\t}\n\n\trotateObjAroundOrigin(pivot, lat, lng) {\n\t\tGlobe.rotateAroundWorldAxis(pivot, this.state.xAxis, -lat * Math.PI / 180, false);\n\t\tGlobe.rotateAroundWorldAxis(pivot, this.state.yAxis,  lng * Math.PI / 180, true);\n\t}\n\n\tstatic rotateAroundWorldAxis(object, axisNorm, radians, second) {\n\t\tlet rotWorldMatrix = new THREE.Matrix4();\n\t\trotWorldMatrix.makeRotationAxis(axisNorm, radians);\n\t\tif (second) rotWorldMatrix.multiply(object.matrix); // pre-multiply\n\t\tobject.matrix = rotWorldMatrix;\n\t\tobject.rotation.setFromRotationMatrix(object.matrix);\n\t}\n\n\trotateCamera() {\n\t\tlet lng = this.gCamera.rot.lng * Math.PI / 180;\n\t\tlet lat = this.gCamera.rot.lat * Math.PI / 180;\n\n\t\tthis.gCamera.position.x = Math.sin(lng) * Math.cos(lat) * this.gCamera.distance;\n\t\tthis.gCamera.position.y = Math.sin(lat) * this.gCamera.distance;\n\t\tthis.gCamera.position.z = Math.cos(lng) * Math.cos(lat) * this.gCamera.distance;\n\t\tthis.gCamera.lookAt(this.state.origin);\n\n\t\t//this.rotateObjAroundOrigin(this.gCamera.userData.pivot, lat, lng); // this is faster, but it doesn't update camera.position, which is necessary for the glow\n\n\n\t\tthis.gScene.userData.earth.userData.glow.material.uniforms.viewVector.value = this.gCamera.position;\n\t}\n\n\tstatic screenToGlobeCoords(mouseX, mouseY, camera, earth) {\n\t\tlet mouse = new THREE.Vector2();\n\t\tmouse.x = mouseX*2-1;\n\t\tmouse.y = mouseY*2-1;\n\n\t\tlet raycaster = new THREE.Raycaster();\n\t\traycaster.setFromCamera(mouse, camera);\n\t\tlet intersects = raycaster.intersectObject(earth);\n\t\tif (intersects == null || intersects.length === 0) return;\n\n\t\tlet spherePoint = new THREE.Vector3();\n\t\tspherePoint.x = intersects[0].point.x;\n\t\tspherePoint.y = intersects[0].point.y;\n\t\tspherePoint.z = intersects[0].point.z;\n\n\t\tlet lat = 90 - Math.acos(spherePoint.y) * 180 / Math.PI;\n\t\tlet lng = ((180 + Math.atan2(spherePoint.x, spherePoint.z) * 180 / Math.PI) % 360) - 180;\n\t\treturn {lat: lat, lng: lng};\n\t}\n\n\tasync init() {\n\t\tlet width = this.mount.clientWidth;\n\t\tlet height = this.mount.clientHeight;\n\n\t\tthis.gScene = new THREE.Scene();\n\t\tthis.gScene.matrixAutoUpdate = false;\n\t\tthis.gCamera = new THREE.PerspectiveCamera(this.props.fovY || 75, width/height, 0.1, 10); // set the far value at 1.55 to not render the back of the globe\n\n\t\tthis.gCamera.distance = this.props.zoom + 1 || 2;\n\t\tthis.gCamera.position.z = this.gCamera.distance;\n\t\tthis.gCamera.rot = {lng: 0, lat: 0};\n\t\tthis.gCamera.userData.pivot = new THREE.Object3D();\n\t\tthis.gCamera.userData.pivot.add(this.gCamera);\n\t\tthis.gScene.add(this.gCamera.userData.pivot);\n\n\t\tthis.gRenderer = new THREE.WebGLRenderer({antialias: false});\n\t\tthis.gRenderer.setPixelRatio(window.devicePixelRatio);\n\t\tthis.gRenderer.setSize(width, height);\n\t\tthis.gRenderer.setClearColor(this.props.backgroundColor || 0x000000, 1);\n\n\t\tthis.mouseRotationSensitivity = this.props.mouseRotationSensitivity || 0.1;\n\t\tthis.ambientRotationRate = this.props.ambientRotationRate || 1;\n\n\t\t// my own orbitControls, without the problem of unexposed rotate methods\n\t\tthis.isDragging = false;\n\t\tthis.dragPrev = {x: 0, y: 0};\n\n\t\tthis.gRenderer.domElement.addEventListener(\"click\", e => {\n\t\t\tlet coords = Globe.screenToGlobeCoords(e.offsetX/width, (height-e.offsetY)/height, this.gCamera, this.gScene.userData.earth);\n\t\t\tif (coords == null) return;\n\t\t\tif (this.mouseCoords.x !== e.offsetX || this.mouseCoords.y !== e.offsetY) return;\n\t\t\tthis.props.onGlobeClick(coords);\n\t\t});\n\t\tthis.gRenderer.domElement.addEventListener(\"mousedown\", e => {\n\t\t\tthis.isDragging = true;\n\t\t\tthis.mouseCoords = {x: e.offsetX, y: e.offsetY};\n\t\t});\n\t\tthis.gRenderer.domElement.addEventListener(\"mousemove\", e => {\n\t\t\tif (this.isDragging) {\n\t\t\t\tthis.gCamera.rot.lng -= (e.offsetX-this.dragPrev.x)*this.mouseRotationSensitivity;\n\t\t\t\tthis.gCamera.rot.lat += (e.offsetY-this.dragPrev.y)*this.mouseRotationSensitivity;\n\n\t\t\t\tif (this.gCamera.rot.lat > 90) this.gCamera.rot.lat = 90;\n\t\t\t\tif (this.gCamera.rot.lat < -90) this.gCamera.rot.lat = -90;\n\t\t\t\tif (this.gCamera.rot.lng > 180) this.gCamera.rot.lng -= 360;\n\t\t\t\tif (this.gCamera.rot.lng < -180) this.gCamera.rot.lng += 360;\n\n\t\t\t\t//this.rotateCamera(); // uncomment if not animating by default\n\t\t\t\t//this.draw();\n\t\t\t}\n\n\t\t\tthis.dragPrev = {x: e.offsetX, y: e.offsetY};\n\t\t});\n\n\t\t// not sure if this is anti-pattern TODO figure out if this is anti-pattern\n\t\tdocument.addEventListener(\"mouseup\", () => this.isDragging = false);\n\n\t\tthis.gSticks = {};\n\t\tthis.gSticks.toRender = new THREE.Group();\n\t\tthis.gScene.add(this.gSticks.toRender);\n\t\tthis.gSticks.fromSource = [];\n\n\t\tthis.gScene.add(new THREE.AmbientLight(0xffffff, 1));\n\n\t\tthis.gFocus = {\n\t\t\tduration: this.props.focusDuration || 1000,\n\t\t\tstartTime: 0,\n\t\t\tstartLoc: {\n\t\t\t\tlat: 0,\n\t\t\t\tlng: 0\n\t\t\t},\n\t\t\tcurProgress: 0,\n\t\t};\n\n\t\t// earth texture\n\t\tlet earth = new THREE.Group();\n\t\tthis.gScene.add(earth);\n\t\tnew THREE.TextureLoader().load(\"data/img/earthnight8k.jpg\", tex => {\n\t\t\tlet geometry = new THREE.SphereGeometry(0.999, 360, 180); // at 0.995, markers are at 32km above sea level\n\t\t\tlet material = new THREE.MeshBasicMaterial({map: tex, overdraw: 0.5/*color: 0x050505*/});\n\t\t\tlet mesh = new THREE.Mesh(geometry, material);\n\t\t\tmesh.rotateY(3*Math.PI/2);\n\t\t\tmesh.doubleSided = false;\n\t\t\tearth.add(mesh);\n\n\t\t\t// earth glow\n\t\t\tlet glowMaterial = this.getGlowMaterial(0.4, 6, this.props.earthGlowColor || defaultEarthGlowColor);\n\t\t\tlet earthGlow = new THREE.Mesh(geometry, glowMaterial);\n\t\t\tearthGlow.scale.multiplyScalar(1.55);\n\t\t\tearth.add(earthGlow);\n\n\t\t\tearth.userData.object = mesh;\n\t\t\tearth.userData.glow = earthGlow;\n\n\t\t\t//this.draw();\n\t\t});\n\n\t\t// load borders\n\t\tthis.addBordersToScene(await loadBorders(\"data/maps/worldBorders.json\"), earth);\n\t\tthis.addBordersToScene(await loadBorders(\"data/maps/state/stateBorders.json\"), earth);\n\n\t\tthis.addMarkersToScene(2, 12, earth);\n\n\t\tthis.gScene.userData.earth = earth;\n\n\t\twindow.setInterval(() => console.log(this.gSticks.toRender.children.length), 1000);\n\n\t\tthis.mount.appendChild(this.gRenderer.domElement);\n\t}\n\n\tasync componentDidMount() {\n\t\tawait this.init();\n\t\tthis.animate();\n\t}\n\n\t/*shouldComponentUpdate(nextProps, nextState) {\n\t\t/!*return (this.props.focusPoint !== nextProps.focusPoint && nextProps.focusPoint != null)\n\t\t\t|| (this.props.sticks !== nextProps.sticks);*!/\n\t\treturn true;\n\t}*/\n\n\tcomponentDidUpdate(prevProps) {\n\t\tif (this.props.focusPoint !== prevProps.focusPoint && this.props.focusPoint != null) {\n\t\t\tthis.setState({focusing: true});\n\t\t\tthis.gFocus.startTime = Date.now();\n\n\t\t\tlet startLat = this.gCamera.rot.lat;\n\t\t\tlet startLng = this.gCamera.rot.lng;\n\t\t\tlet stdDist = this.props.focusPoint.lng - startLng;\n\n\t\t\t// just works, no reason to try to figure it out\n\t\t\tif (Math.abs(stdDist) > 180) startLng -= 360;\n\t\t\tstdDist = this.props.focusPoint.lng - startLng;\n\t\t\tif (Math.abs(stdDist) > 180) startLng += 720;\n\n\t\t\tthis.gFocus.startLoc = {lat: startLat, lng: startLng};\n\t\t\t//requestAnimationFrame(this.animate);\n\t\t}\n\n\t\tif (this.props.sticks !== prevProps.sticks) {\n\t\t\tthis.addSticks(this.props.sticks);\n\t\t}\n\t}\n\n\tanimate(timestamp) {\n\t\tif (!timestamp) {\n\t\t\trequestAnimationFrame(this.animate);\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.state.focusing) this.focus();\n\t\telse {\n\t\t\tif (!this.gCamera.userData.lastRenderTime) this.gCamera.userData.lastRenderTime = timestamp;\n\t\t\tthis.gCamera.rot.lng += this.ambientRotationRate*(timestamp - this.gCamera.userData.lastRenderTime)/1000;\n\t\t\tif (this.gCamera.rot.lng > 180) this.gCamera.rot.lng -= 360;\n\t\t\tthis.rotateCamera();\n\t\t}\n\n\t\tthis.animateSticks();\n\n\t\tthis.draw();\n\t\tthis.gCamera.userData.lastRenderTime = timestamp;\n\t\trequestAnimationFrame(this.animate);\n\t}\n\n\tfocus() {\n\t\tlet curTime = Date.now();\n\t\tthis.gFocus.curProgress = curTime - this.gFocus.startTime;\n\t\tif (this.gFocus.curProgress > this.gFocus.duration) {\n\t\t\tthis.setState({focusing: false});\n\t\t\tthis.gFocus.curProgress = this.gFocus.duration;\n\t\t}\n\n\t\tlet progress = this.gFocus.curProgress / this.gFocus.duration;\n\t\tthis.gCamera.rot.lat = (this.props.focusPoint.lat - this.gFocus.startLoc.lat) * Globe.d(progress) + this.gFocus.startLoc.lat;\n\t\tthis.gCamera.rot.lng = (this.props.focusPoint.lng - this.gFocus.startLoc.lng) * Globe.d(progress) + this.gFocus.startLoc.lng;\n\n\t\tthis.rotateCamera();\n\t}\n\n\t// Animates by moving the sticks out of the globe. Doesn't work if the sticks are long.\n\t// https://threejs.org/docs/#manual/en/introduction/How-to-update-things\n\tanimateSticks() {\n\t\tlet curTime = Date.now();\n\n\t\tif (this.state.eventDisplayType === \"sticks\") {\n\t\t\tfor (let i in this.gSticks.fromSource) {\n\t\t\t\tlet stick = this.gSticks.fromSource[i];\n\n\t\t\t\tlet lifeLength = curTime - stick.addTime;\n\t\t\t\tif (lifeLength > 1000) continue;\n\n\t\t\t\tstick.toRender.children[0].position.z = 1 + stick.size * (Globe.d(lifeLength/1000)-0.5);\n\t\t\t}\n\t\t} else if (this.state.eventDisplayType === \"circles\") {\n\t\t\tfor (let i = this.gSticks.toRender.children.length-1; i >= 0; i--) {\n\t\t\t\tlet circle = this.gSticks.toRender.children[i].userData.mesh;\n\n\t\t\t\tlet lifeLength = curTime - circle.userData.spawnTime;\n\t\t\t\tif (lifeLength > 1000) this.gSticks.toRender.children.splice(i, 1);\n\t\t\t\telse circle.position.z = 1 + Globe.d(lifeLength/1000)*0.1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO find a better name - mathematical functions usually have 1-letter names, but that's discouraged in JS\n\tstatic d(t) {return -2*t*t*(t-1.5);} // cubic relation, maybe experiment with different functions here?\n\n\tdraw() {\n\t\tthis.gRenderer.render(this.gScene, this.gCamera);\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div className=\"globe-rootDiv\"\n\t\t\t\tref={(r) => this.mount = r}\n\t\t\t/>\n\t\t)\n\t}\n}\n","import React, { Component } from 'react';\nimport './App.css';\nimport Globe from \"./components/Globe\";\n\nclass App extends Component {\n\n\tstate = {\n\t\tsticks: [],\n\t\tfocusPoint: null\n\t};\n\n\thandleGlobeChange() {}\n\n\tonGlobeClick(coords) {\n\t\t/*this.setState({sticks: [...this.state.sticks, { // add stick at click location\n\t\t\t\tid: 2,\n\t\t\t\ttype: \"error\",\n\t\t\t\tsize: 0.2,\n\t\t\t\tlat: coords.lat,\n\t\t\t\tlng: coords.lng,\n\t\t}]});*/\n\t}\n\n\tstatic shuffle(b) {\n\t\tlet a = b.slice(0);\n\t\tfor (let i = a.length-1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i+1));\n\t\t\tif (i === j) continue;\n\t\t\t[a[i], a[j]] = [a[j], a[i]];\n\t\t}\n\t\treturn a;\n\t}\n\n\tstatic randomizeSticks(sticks, total, count) {\n\t\tsticks = App.shuffle(sticks).slice(0, count);\n\t\tsticks = [...sticks, ...App.generateSticks(total-count)];\n\n\t\treturn sticks;\n\t}\n\n\tstatic generateStick() {\n\t\treturn {\n\t\t\ttype: Math.random() < 0.2 ? \"error\" : \"normal\",\n\t\t\tsize: Math.random() * 0.3,\n\t\t\tlat: Math.random() * 180 - 90,\n\t\t\tlng: Math.random() * 360 - 180,\n\t\t};\n\t}\n\n\tstatic generateSticks(count) {\n\t\tconst sticks = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tsticks.push(App.generateStick());\n\t\t}\n\t\treturn sticks;\n\t}\n\n\tsetupTestEnvironment() {\n\t\tsetInterval(() => {\n\t\t\tlet sticks = App.randomizeSticks(this.state.sticks, 100, 50);\n\t\t\tthis.setState({sticks});\n\t\t}, 1000);\n\t}\n\n\tcomponentDidMount() {\n\t\tthis.setupTestEnvironment();\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div style={{width:\"100%\", height:\"100%\", position:\"absolute\", top:\"0\", left:\"0\"}}>\n\n\t\t\t\t<button onClick={()=>{this.setState({focusPoint: {lat: 44.6, lng: 33.5}})}}>focus</button>\n\t\t\t\t<div style={{width:\"100%\", height:\"100%\", display:\"inline-block\"}}>\n\t\t\t\t\t<Globe\n\t\t\t\t\t\tfocusPoint={this.state.focusPoint}\n\t\t\t\t\t\tsticks={this.state.sticks}\n\t\t\t\t\t\tstickWidth={0.008}\n\t\t\t\t\t\teventDisplayType={\"circles\"}\n\t\t\t\t\t\tonChange={this.handleGlobeChange.bind(this)}\n\t\t\t\t\t\tonGlobeClick={this.onGlobeClick.bind(this)}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default App;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n\n              // Execute callback\n              if (config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}